---
title: Redis 知识点
date: 2024-10-25 14:24:33
layout: post
categories: [Redis 知识点整理]
tags: [Redis]
comments: true
cover: /img/redis_logo.png
description: Redis 整理知识点
---



# 1. 基础概念

## Redis 通常应用于哪些场景？

1. **缓存**：

- Redis 最常用的场景作为缓存层，以减少数据库的负载，提高数据读取速度。

  例如，常用的用户会话数和页面渲染结果可以存储在 Redis 中

2. **实时系统**：

- Redis 支持快速的数据写入和读取，非常适合用于实时分析，如网站点击统计，实时排行榜。

3. **消息队列**：

- 利用 Redis 的 List 和 Pub/Sub 功能，可以实现轻量级的消息队列，适用于任务处理和异步消息传递。

4. **分布式锁**：

- Redis 可以用作分布式锁的实现，确保在分布式系统资源的安全访问，避免竞态条件。

5. **计数器**：

- Redis 的原子性操作非常适合用作计数器。例如，可以使用 Redis 来统计页面访问量、点赞数、评论数等。通过 INCR 命令可以轻松实现高效的计数。



## Redis 为什么这么快？

三个方面：存储方式、优秀的线程模型以及 IO 模型、高效的数据结构：

- Redis 将数据存储在内存中，提供快速的读写速度，相比于传统的磁盘数据库，内存访问速度快得多。
- Redis 使用单线程事件驱动模型结合 I/O 多路复用，避免了多线程上下文切换和竞态条件，提高了并发处理效率。
- Redis 提供多种高效的数据结构（如字符串、哈希、列表、集合等），这些结构经过优化，能够快速完成各种操作。

> 扩展知识
>
> **存储方式：**
>
> ![](/img/0024-计算机读取数据.png )
>
> 看一下 访问 SSD 和 Redis 访问 RAM 速度比较，1000倍左右。传统硬盘可能还会更长大概要 1~10 毫秒。
>
> **优秀的线程模型以及 IO 模型：**
>
> Redis 使用单个主线程来执行命令，不需要进行线程切换，避免了上下文切换带来的性能开销，大大提高了 Redis 的运行效率和响应速度。
>
> Redis 采用了 I/O 多路复用技术，实现了单个线程同时处理多个客户端连接的能力，从而提高 Redis 的并发能力。
>
> But，Redis 并不是一直都是单线程的，自 4.0 开始，Redis 就引入了 Unlink 这类命令，用于异步执行删除等操作，还有在 6.0 之后，Redis 为了进一步提升 I/O 的性能，引入了多线程的机制，利用多线程的机制并发处理网络请求，从而减少 Redis 由于网络 I/O 等待造成的影响。
>
> ### 几种线程模型：
>
> - **同步阻塞，BIO（Blocking  I/O）**
>
> - **同步非阻塞 I/O，NIO（No Blocking I/O）**：没数据的时候可以不去阻塞，直接返回错误。
>
> - **I/O 多路复用**：**只用一个线程去查看多个连接是否有数据已准备就绪**，仅需往 select 注册需要被监听的连接，由 select 来监听它锁管理的连接是否数据已就绪，如果有则可以通知别的线程来 read读取数据，这个 **read 和之前的一样，还是会阻塞用户线程**。
>
>   这样一来就可以 **用少量的线程去监控多条连接**，减少1了线程的数量，降低了内存的消耗且减少了上下文切换的次数。
>
>   **所谓的多路指的是多条连接，复用指的是用一个线程就可以监控这么多条连接**
>
> - **信号驱动式 I /O**：就是基于 I/O 多路复用（时刻去查询数据是否准备就绪），改成由内核去告知 数据已准备就绪，然后用户线程再去 read（**还是会阻塞**）
>
>   但是通常用的TCP协议的socket可以产生信号事件有7种，应用程序无法区分到底用的是哪种，如果是用 UDP 的话是可以的，UDP 没有那么多事件。
>
> - **异步 I/O，AIO（Asynchronous I/O）**：Linux 对异步 I/O 支持不足，所以还用不了异步 I/O；而 Windows 是真正的 AIO，但是我们的服务器一般都是部署在 Linux 上的，所以主流的还是 I/O 多路复用。



## 为什么 Redis 设计为单线程？6.0 版本为何引入多线程？

**单线程设计原因：**

- Redis 的操作是基于内存的，其大多数操作的性能瓶颈主要不是 CPU 导致的
- 使用单线程模型，代码简便的同时也减少了线程上下文切换带来的性能开销
- Redis 在单线程的情况下，使用 I/O 多路复用模型就可以提高 Redis I/O 利用率了

**6.0 版本引入多线程的原因：**

- 随着数据规模的增长、请求量的增多，Redis 的执行瓶颈主要于网络 I/O。引入多线程处理可以提高网络 I/O 处理速度

> 扩展知识
>
> **Redis 引入多线程之后，有没有带来什么线程安全问题呢？**
>
> - 首先要注意的是，多线程应用到了什么地方？Redis6.0 引入的多线程只针对 **网络请求模块**，**对于读写命令部分还是采用单线程**，所以网络安全问题并不存在。
> - 综合来讲，多路复用 + 单线程的设计并不能很好地解决网络 I/O 瓶颈的问题，这时候就可以考虑利用 CPU 的多核优势，即利用多线程处理网络请求的方式来提高效率，然后对于读写命令，Redis 依旧采用单线程命令
>
> 需要注意的是，Reids6.0 的多线程是默认禁用的，只是用主线程，因为大部分公司并发量实际上还用不上这个。
>
> 如果要开启需要配置 `io-threads-do-reads` 参数为 `yes`





# 2. Redis 结构 数据

## Redis 种常见的数据结构有哪些？

Redis 中常见的数据结构主要有五种，这五种类型分别为：String（字符串）、List（列表）、Hash、Set（集合）、Zset（有序集合，也叫sorted set）

- ### **Sting**

  字符串是 Redis 种最基本的数据类型，可以存储任何类型的数据，包括文本、数字和二进制数据。它的最大长度为 512MB

  **使用场景**：

  - **缓存：**存储临时数据，如用户会话，页面缓存
  - **计数器：**用于统计访问量、点赞数等，通过原子操作增加或减少
  - **分布式锁**
  - **分布式 session**

- ### Hash

  哈希是一个 kv 键值对集合，适合存储对象的属性。Redis 内部使用哈希表实现，适合小规模数据。

  **使用场景：**

  - **商品详情：**存储商品的各个属性，方便快速检索
  - **购物车**
  - **缓存对象**

- ### List

  列表是有序的字符串集合，支持从两端推入和弹出元素，底层实现了 **双向链表**

  **使用场景：**

  - **消息队列：**用于简单任务调度、消息传递等场景，通过 `LPUSH`  和 `RPOP`操作实现生产者消费者模式
  - **历史记录：**存储用户操作的历史，便于快速访问

- ### Set

  集合是无序且不重复的字符串集合，使用哈希表实现，支持快速查找和去重操作

  **使用场景：**

  - **标签系统：**存储用户的兴趣标签、避免重复
  - **唯一用户集合：**记录访问过某个页面的唯一用户，方便进行分析
  - **集合聚合计算（交集、并集、差集），如点赞、共同关注、收藏**

- ### Sorted Set（Zset）

  有序集合类似于集合，但每个元素都有一个分数（score），用于排序。**底层使用跳表实现**，支持快速的范围查询

  **使用场景：**

  - **排行榜：**存储用户分数，实现实时排行榜
  - **任务调度：**根据任务的优先级进行排序，方便调度执行

> ### 四种高级的数据结构
>
> Redis 后续又增加了几种数据结构：**BitMap（2.2 版新增）**、**HyperLogLog（2.8 版新增）**、**GEO （3.2 版新增）**、**Stream（5.0 版新增）**
>
> - #### BitMap
>
>   BitMap 是一种以位为单位存储数据的高效方式，适合用来表示布尔值（如存在性、状态等）。每个 bit 可以表示一个状态（0 或 1），使用空间少且操作快速
>
> - #### HyperLogLog
>
>   HyperLogLog 是一种概率性数据结构，主要用于估算基数（不同元素的数量），内存占用固定，适合处理大规模数据的去重和计数
>
> - #### GEO
>
>   GEO 是 Redis 提供的一种用于存储地理位置信息的数据结构，可以存储经纬度信息并支持空间查询，例如计算距离和获取范围内的坐标
>
> - #### Stream
>
>   Stream 是 Redis 提供的一种日志数据结构，适合于存储事件序列数据或消息流。支持高效的消息生产和消费模式，具有持久性和序列化特性



## Redis 中跳表的实现原理是什么？

跳表主要是通过 **多层链表来实现**，底层链表保存所有元素，而每一层链表都是下一层的子集。

很简单，直接看文档：https://www.mianshiya.com/bank/1791375592078610434/question/1780933295597449217



## Redis 中的 hash 是什么？

Redis 的 hash 是一种 kv 键值对集合，适合存储对象类型的数据。每个 hash 由一个唯一的键和一组字段 组成：

- **内存高效**：适合存储小数据，使用哈希表实现，能够在内存中高效存储和操作
- **灵活性强：**支持快速的字段操作（如增、删、改、查），非常适合存储对象的属性

> 扩展知识
>
> #### Hash 底层实现解析：
>
> - Redis 6 及之前，Hash 的底层是压缩列表加上哈希表的数据结构（ ziplist + hashtable ）
> - Redis 7 之后，Hash 的底层是紧凑列表（ Listpack ）加上哈希表的数据结构（ Listpack + hashtable ）
>
> ziplist 和 listpack 查找 key 的效率是类似的，时间复杂度都是 O（0），主要区别就在于 listpack 解决了 ziplist 的 **级联更新** 问题



## Redis 数据过期后的删除策略是什么？

主要有两种 **定期删除** 和 **惰性删除**：

- **定期删除：** Redis 每隔一段时间（默认为 100 毫秒）会随机检查一定数量的键，如果发现过期键，则将其删除。这种方式能够在后台持续清理过期数据，防止内存膨胀。
- **惰性删除：** 在每次访问键时，Redis 检查该键是否已过期，如果过期，则将其删除。这种策略保证了在使用过程中只删除不再需要的数据，但在不访问过期键时不会立即清除。

**问题：**

- 定期删除：定期删除，需要其频繁的开启任务去扫描判断过期的数据进行删除，会对 Redis 的性能产生影响，并且控制的时长和频率难以确定。
- 惰性删除：对 CPU 友好，但是过期不主动删除，容易导致内存泄露问题。

> #### 最佳方案是： 惰性删除 + 定期删除 一起使用 （内存满了主动删除其实是属于一种异常兜底处理方案）



## Redis 数据的淘汰策略（内存回收机制）？

是除了 定期删除 和 惰性删除 的一个数据淘汰机制。

当 Redis 内存使用达到设置的 maxmemory 限制时，会触发内存回收机制，此时会主动删除一些过期的键和其它不需要的键。

具体的淘汰策略有以下几种：

- **volatile-lru：** 从设置了过期时间的键中使用 LRU （最近最少使用）算法删除键
- **allkeys-lru**：对所有的键使用 LRU 算法删除
- **volatile-lfu：** 从设置了过期时间的键中使用 LFU （使用频率最少）算法删除键
- **allkeys-lfu：** 对所有的键使用 LFU 算法进行删除
- **volatile-random：** 从设置了过期时间的键中随机删除键
- **allkeys-random：** 从所有键中随机删除键
- **volatile-ttl：** 从设置了过期时间的键中根据 TTL（优先删除存活时间最少）删除键
- **noevivtion：** 内存满了，直接不给用了，直接报错，不删除键 -----------------------------------------------> （默认）



## Redis 中的 Big Key 问题是什么？如何解决？

大 key 指的是占用内存比较大的键值对

1. **危害：**
   - 其它命令阻塞时间过长
   - 网络传输慢甚至阻塞
   - 客户端超时
2. **解决：**
   - 压缩 + 拆分 + 不要存储一些不必要的值
3. **压缩：**
   - 将存储的值先进行压缩，减少占用的空间
4. **拆分：**将大 Key，拆分成一个个小的 key，减小单个 key 占用的空间
5. **Redis 内置：** redis 有内置的指令可以检查大 key （直接：**--bigkeys**）



## 如何解决 Redis 中的热点 key 问题？

Redis 中 的热点 key 问题是指某些 Key 被频繁访问，导致 Redis 的压力过大，进而影响整体性能甚至导致集群节点故障。

解决热点 Key 问题的主要方法包括：

- **热点 Key 拆分：**将热点数据分散到多个 Key 中，例如通过引入随机前缀，使不同用户请求分散到多个 Key，避免集中访问单一 Key。
- **多级缓存：** 在 Redis 前增加其他缓存层（如 CDN、本地缓存），以分担 Redis 的访问压力。
- **读写分离：** 通过 Redis 主从复制，将读请求分发到多个从节点，从而减轻单节点压力。
- **限流和降级：** 在热点 Key 访问过高时，应用限流策略，减少对 Redis 的请求，或者在必要时返回降级的数据和空值。

> 扩展知识
>
> **如何发现：** 业务 + 集群 + hotkeys + 客户端收集
>
> **这么解决：**  拆分 + 多级缓存 + 读写分离 + 限流降级



## Redis 的持久化机制有哪些？

Redis 提供两种主要的持久化机制：

**RDB（Redis Database Backup）快照：**

- RDB 是通过生成某一时刻的数据快照来实现持久化的，可以在特定时间间隔内保存数据的快照。
- 适合灾难恢复和备份，能生成紧凑的二进制文件，但可能会在崩溃时丢失最后一次快照之后的数据。

**AOF（Append Only File）日志：**

- ​	AOF 通过将每个写操作追加到日志文件中实现持久化，支持将所有写操作记录下来以便恢复。
- 数据恢复更为精确，但文件体积较大，重写时可能会消耗更多资源。

Redis 4.0 新增了 RDB 和 AOF 的混合持久化机制.









# 3. 主从 / 集群

## Redis 主从复制的实现原理是什么？

Redis 的主从复制是指一个 Redis 实例（主节点）可以将数据复制到一个或多个从节点（从节点），从节点 从 主节点获取数据并保持同步。

主从架构可以实现读写分离：写操作可以请求主节点、读操作可以交给从节点

**复制流程：**

- **连接：**从节点通过向主节点发送 **`PSYNC`** 命令建立连接
- **全量复制：**如果是一次连接或之前的连接失效，从节点会请求全量复制，主节点将当前的**数据快照（RDB文件）**发送给从节点
- **增量复制：**全量复制完毕后，主从之前会保持一个长连接，主节点会通过这个连接将后续的写操作传递给从节点执行，来保证数据的一致

> 扩展知识：
>
> **主从复制**有两种方式：**`全量复制`** 和 **`增量复制`**
>
> 1. **全量同步：**
>
> - 从节点发送 `psync ? -1`，触发同步
> - 从节点收到从节点的 psync 命令之后，发现 runid 没值，判断是全量同步，返回 fullresync 并带上主服务器的 runid 和当前复制进度，从服务器会存储这两个值。
> - 主节点执行 bgsave 生成 RDB 文件，在 RDB 文件生成过程中，主节点新接收到的写入数据的命令会存储到 `replication buffer` 中。
> - RDB 文件生成完毕后，主节点将其发送给从节点，从节点清空旧数据，加载 RDB 的数据。
> - 等到从节点中 RDB 文件加载完成之后，主节点将 replication buffer 缓存的数据发送给从节点，从节点执行命令，保证数据的一致性。
>
> 待同步完毕后，主从之间会保持一个长连接，主节点会通过这个连接将后续的写操作传递给从节点执行，来保证数据的一致。
>
> 2. **增量同步：**
>
> 主从之间网络可能不稳定，如果连接断开，主节点部分写操作未传递给从节点执行，主从数据就不一致。
>
> 此时有一种选择是再次发起全量同步，但是同步数据量很大的，非常耗时。
>
> 因此Redis在2.8版本引入了增量同步（psync其实就算2.8引入的命令），仅需把连接断开期间的数据同步给从节点就好了。
>
> `repl_backlog_buffer` 是一个环形缓冲区，默认大小为 1m。主节点会将写入命令存到这个缓冲区中，但是大小有限，待写入的命令超过 1m 后，会覆盖之前的数据，因为是环形写入，
>
> 增量同步也是 psync 命令，如果主节点判断从节点传递的 runid 的主节点一致，且根据 offset 判断数据还在 `repl_backlog_buffer` 中，则说明可以进行增量同步。
>
> 于是就去 `repl_backlog_buffer` 查找对应 offset 之后的命令数据，写入到 `replication buffer` 中，最终将其发送给 slave 节点。slave 节点收到指令之后执行对应的命令，一次增量同步过程就完成了。
>
> 如果 offset 判断数据已经被覆盖了，此时只能触发全量同步！
>
> 因此可以调整 `repl_backlog_buffer` 大小，尽量避免出现全量同步
>
> 
>
> - `replication buffer` （复制缓冲区）和 `repl_backlog_buffer`   (积压缓冲区) 的区别？
>   - `replication buffer`： 每个节点同步速度不一样，**主节点会为每个从节点都创建一个** `replication buffer` ,**用于实时传输写命令**，且大小是动态的，因为同步速度比较慢的服务器，需要更多的内存来缓存数据。
>   - `repl_backlog_buffer`：在主节点上只有一个，**存储最近的写命令**，用于从服务器重新连接进行部分重同步



## Redis 集群的实现原理是什么？

Redis 集群（Redis cluster）是通过多个 Redis 实例组成的，**每个实例存储部分的数据（即每个实例之间的数据是不重复的）**

具体是采用哈希槽（Hash Slot）机制来分配数据，将整个键空间划分为 16384 个槽（slots）。每个 Redis 实例负责一定范围的哈希槽，数据的 key 经过哈希函数计算后对 16384 取余可定位到对应的节点。

客户端在发送请求时，会通过集群的任意节点进行连接，如果该节点存储了对应的数据则直接返回，反之该节点会根据请求的键值计算哈希槽并路由到正确的节点。

简单来说，集群就是通过多台机器分担单台机器上的压力。

> - 作用：
>   - 集群中有多个 master，每个 master 保存不同数据（海量数据）
>   - 每个 master 都可以有多个 slave 节点（高并发读）
>   - master 之间通过 ping 检测彼此健康状态
>   - 客户端请求可以访问集群任意节点，最终都会被转发到正确节点（路由规则）
> - 怎么存储和读取的：
>   - 分片集群引入了哈希槽的概率，有 16384 个哈希槽
>   - 将 16384 个哈希槽分配到不同的实例
>   - 读写数据：根据有效部分计算哈希值，对 16384 进行取余（有效部分 set{aaa}name tiantian），余数作为插槽，寻找插槽所在的实例



# 4. 其它

## Redis 支持事务吗？如何实现？

Redis 是支持事务的，**但是它和 MySQL 的事务有所不同**，MySQL 中的事务主要支持 ACID 的特性，而 Redis 中的事务主要保证的是多个命令执行的原子性，即所有的命令在一个原子操作中执行，不会被打断。

But，MySQL 是支持事务回滚的，但是 Redis 是**不**支持事务回滚的

> 扩展知识
>
> #### Redis 的事务
>
> 具体流程如下：
>
> 1. **开始事务：** 使用 `MULTI` 命令开始一个事务，之后的所有命令都会被排队。
> 2. **添加命令：** 在事务添加命令，这些命令不会立即执行，而是存储在队列中。
> 3. **执行事务：** 使用 `EXEC` 命令执行队列中的所有命令，确保原子性。
> 4. **取消事务：** 使用 `DISCARD` 命令可以放弃事务，清空命令队列。
> 5. **监视键：** 使用 `WATCH` 命令可以监视一个或多个键，如果在事务执行前这些键被修改，则 `EXEC` 将不会被执行，确保数据一致性。
>
> #### Redis 中的事务不支持回滚
>
> 从 Redis 2.6.5 开始，服务器会在累计命令的过程中检测到错误，此时执行 EXEC 会拒绝执行事务，并且返回一个错误，同时求丢该事务。
>
> But，在事务执行的过程中发生了错误，Redis 会继续执行剩下的指令，而不会对事务进行回滚，这是 Redis 和 MySQL 最不一样的地方，并且也 **不支持多种隔离级别的设置**，因为 Redis 是单线程执行，**只能是串行隔离级别**。
>
> - 可以认为 Redis 的事务是一个残血事务，**更多只是一个噱头，不是我们平时理解的事务**。
> - **Redis 事务：** 保证了多个命令在一个原子操作中执行，但不支持事务回滚和多种隔离级别。
> - **Lua 脚本：** 提供了更强大的原子执行能力，适合实现复杂的逻辑



## Redis 的 Lua 脚本的功能是什么？如何使用？

Redis 的 Lua 脚本功能允许用户在 Redis 服务器端执行自定义的 Lua 脚本，以实现原子操作和复杂逻辑。

其核心包括：

- **原子性：** Lua 脚本的所有命令在执行过程中是原子的，避免了并发修改带来的问题。
- **减少网络往返次数：** 通过在服务器端执行脚本，减少了客户和服务器之间的网络往返次数，提高性能。
- **复杂操作：** 可以在 Lua 脚本中执行复杂的逻辑，比如批量更新、条件更新等，超过了单个 Redis 命令的能力。

常见的基于 Redis 实现分布式锁就需要结合 Lua 脚本来实现，在Redisson实现的分布式锁的源码中也可以看见 Lua 脚本的使用。

> 扩展知识
>
> ### Java 中使用 Lua 脚本
>
> 在 Java 中使用 Lua 脚本操作 Redis 需要用 `Jedis`
>
> **依赖：**
>
> ```xml
> <dependency>
>     <groupId>redis.clients</groupId>
>     <artifactId>jedis</artifactId>
>     <version>4.0.1</version>
> </dependency>
> ```
>
> 具体看一下：https://www.mianshiya.com/bank/1791375592078610434/question/1780933295618420738
>
> 我个人对 Lua 脚本有个大概的学习，这里就不再去啰嗦赘述



## Redis 的 Pipeline（批量执行，但没有原子性） 功能是什么？

Redis 的 Pipeline 功能允许客户端在一次网络请求中批量发送多个命令，以减少网络延迟并提高性能。通过将多个命令打包发送，客户端可以在不等待每个命令响应的情况下继续发送其他命令，从而显著提高吞吐量。

**好处：**

- 节省了网络传输时间（RTT 往返时间）
- 减少了 Redis 服务端上下文切换带来的开销

**BUT**

- Pipeline 并不保证命令的原子性，也不支持事务特性。如果某个命令失败，其他命令仍会继续执行。
- Redis 的事务是通过 MULTI、EXEC 命令实现的，可以保证一组命令的原子性。

> ### Pipeline 示例代码
>
> **Java 的 Jedis 库实现：**
>
> ```java
> import redis.clients.jedis.Jedis;
> import redis.clients.jedis.Pipeline;
> 
> public class RedisPipelineExample {
>     public static void main(String[] args) {
>         // 创建 Redis 连接
>         Jedis jedis = new Jedis("localhost", 6379);
> 
>         // 开始 Pipeline
>         Pipeline pipeline = jedis.pipelined();
> 
>         // 批量设置键值对
>         for (int i = 0; i < 1000; i++) {
>             pipeline.set("key" + i, "value" + i);
>         }
> 
>         // 执行所有命令
>         pipeline.sync();
> 
>         // 关闭连接
>         jedis.close();
>     }
> }
> ```





